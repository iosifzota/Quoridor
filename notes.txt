* Piece
position: pair<x, y>
enum Direction(NONE, NORHT, SOUTH, EAST, WEST)
** Pawn
origin: Direction
** PlaceableWall (private constructor)
direction: Direction
instance: PlaceableWall
used: bool
getInstance() { iff !used; used = true } -> instance;
retInstance() { used = false }
* Board
board: matrix<optional<Pawn>>
trenchNorthSouth: Trench<9, 9-1>
trenchEastWest: Trench<9-1, 9>
* Trench<int N, int M>
grid: bitset_matrix<N, M>
atForward(n, m) -> grid[n][m] const&
max = max{N, M}
atBackward(n, m) -> gird[n - (max - N)][ m - (max - M)] const&  // _Last_
* PiecesPool
pawns: array<4, Pawn>
wallsCount: size_t
placeableWall: PlaceableWall
getPlaceableWallRef() -> placeableWall&
* Player<int N>
wallsCount: size_t
placeableWallRef;
pickWall(...) -> PlaceableWall::getInstance(...)
placeWall(PlaceableWall& w, Board& b) { tryApplyWall(w, b); w.retInstance() } noexcept;

* Footnotes

template<int N, int M, typename T>
using matrix = array<N, array<M, T>>
template<int N, int M>
using bitset_matrix = array<N, bitset<M>>
